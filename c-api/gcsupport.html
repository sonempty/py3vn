<!DOCTYPE html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Supporting Cyclic Garbage Collection &#8212; Dịch tiếng Việt Python 3.5 documentation</title>
    
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '3.5',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="Dịch tiếng Việt Python 3.5 documentation" href="../index.html" />
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <link rel="shortcut icon" type="image/png" href="../_static/favicon.png" />
    <meta name="viewport" content="width=device-width,initial-scale=0.8">
    

  </head>
  <body role="document">
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="responsive-menu"><a href="#sidebar-anchor" title="Navigation">&#9776;</a></li>
        <li><a href="../index.html">Dịch tiếng Việt Python 3.5 documentation</a> &#187;</li> 
      </ul>
    </div>
    
        <div class="badge">
            <a href="https://github.com/sonempty/Python-Document-in-Vietnamese">Fork me on GitHub</a>
            <img src="../_static/right-red@2x.png">
        </div>
    
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="supporting-cyclic-garbage-collection">
<span id="supporting-cycle-detection"></span><h1>Supporting Cyclic Garbage Collection<a class="headerlink" href="#supporting-cyclic-garbage-collection" title="Permalink to this headline">¶</a></h1>
<p>Python&#8217;s support for detecting and collecting garbage which involves circular
references requires support from object types which are &#8220;containers&#8221; for other
objects which may also be containers.  Types which do not store references to
other objects, or which only store references to atomic types (such as numbers
or strings), do not need to provide any explicit support for garbage
collection.</p>
<p>To create a container type, the <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_flags" title="PyTypeObject.tp_flags"><code class="xref c c-member docutils literal"><span class="pre">tp_flags</span></code></a> field of the type object must
include the <a class="reference internal" href="typeobj.html#Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code class="xref py py-const docutils literal"><span class="pre">Py_TPFLAGS_HAVE_GC</span></code></a> and provide an implementation of the
<a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code class="xref c c-member docutils literal"><span class="pre">tp_traverse</span></code></a> handler.  If instances of the type are mutable, a
<a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code class="xref c c-member docutils literal"><span class="pre">tp_clear</span></code></a> implementation must also be provided.</p>
<dl class="data">
<dt>
<code class="descname">Py_TPFLAGS_HAVE_GC</code></dt>
<dd><p>Objects with a type with this flag set must conform with the rules
documented here.  For convenience these objects will be referred to as
container objects.</p>
</dd></dl>

<p>Constructors for container types must conform to two rules:</p>
<ol class="arabic simple">
<li>The memory for the object must be allocated using <a class="reference internal" href="#c.PyObject_GC_New" title="PyObject_GC_New"><code class="xref c c-func docutils literal"><span class="pre">PyObject_GC_New()</span></code></a>
or <a class="reference internal" href="#c.PyObject_GC_NewVar" title="PyObject_GC_NewVar"><code class="xref c c-func docutils literal"><span class="pre">PyObject_GC_NewVar()</span></code></a>.</li>
<li>Once all the fields which may contain references to other containers are
initialized, it must call <a class="reference internal" href="#c.PyObject_GC_Track" title="PyObject_GC_Track"><code class="xref c c-func docutils literal"><span class="pre">PyObject_GC_Track()</span></code></a>.</li>
</ol>
<dl class="function">
<dt id="c.PyObject_GC_New">
TYPE* <code class="descname">PyObject_GC_New</code><span class="sig-paren">(</span>TYPE, <a class="reference internal" href="type.html#c.PyTypeObject" title="PyTypeObject">PyTypeObject</a><em>&nbsp;*type</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyObject_GC_New" title="Permalink to this definition">¶</a></dt>
<dd><p>Analogous to <a class="reference internal" href="allocation.html#c.PyObject_New" title="PyObject_New"><code class="xref c c-func docutils literal"><span class="pre">PyObject_New()</span></code></a> but for container objects with the
<a class="reference internal" href="typeobj.html#Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code class="xref py py-const docutils literal"><span class="pre">Py_TPFLAGS_HAVE_GC</span></code></a> flag set.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyObject_GC_NewVar">
TYPE* <code class="descname">PyObject_GC_NewVar</code><span class="sig-paren">(</span>TYPE, <a class="reference internal" href="type.html#c.PyTypeObject" title="PyTypeObject">PyTypeObject</a><em>&nbsp;*type</em>, Py_ssize_t<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyObject_GC_NewVar" title="Permalink to this definition">¶</a></dt>
<dd><p>Analogous to <a class="reference internal" href="allocation.html#c.PyObject_NewVar" title="PyObject_NewVar"><code class="xref c c-func docutils literal"><span class="pre">PyObject_NewVar()</span></code></a> but for container objects with the
<a class="reference internal" href="typeobj.html#Py_TPFLAGS_HAVE_GC" title="Py_TPFLAGS_HAVE_GC"><code class="xref py py-const docutils literal"><span class="pre">Py_TPFLAGS_HAVE_GC</span></code></a> flag set.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyObject_GC_Resize">
TYPE* <code class="descname">PyObject_GC_Resize</code><span class="sig-paren">(</span>TYPE, <a class="reference internal" href="structures.html#c.PyVarObject" title="PyVarObject">PyVarObject</a><em>&nbsp;*op</em>, Py_ssize_t<em>&nbsp;newsize</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyObject_GC_Resize" title="Permalink to this definition">¶</a></dt>
<dd><p>Resize an object allocated by <a class="reference internal" href="allocation.html#c.PyObject_NewVar" title="PyObject_NewVar"><code class="xref c c-func docutils literal"><span class="pre">PyObject_NewVar()</span></code></a>.  Returns the
resized object or <em>NULL</em> on failure.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyObject_GC_Track">
void <code class="descname">PyObject_GC_Track</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em>&nbsp;*op</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyObject_GC_Track" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds the object <em>op</em> to the set of container objects tracked by the
collector.  The collector can run at unexpected times so objects must be
valid while being tracked.  This should be called once all the fields
followed by the <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code class="xref c c-member docutils literal"><span class="pre">tp_traverse</span></code></a> handler become valid, usually near the
end of the constructor.</p>
</dd></dl>

<dl class="function">
<dt id="c._PyObject_GC_TRACK">
void <code class="descname">_PyObject_GC_TRACK</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em>&nbsp;*op</em><span class="sig-paren">)</span><a class="headerlink" href="#c._PyObject_GC_TRACK" title="Permalink to this definition">¶</a></dt>
<dd><p>A macro version of <a class="reference internal" href="#c.PyObject_GC_Track" title="PyObject_GC_Track"><code class="xref c c-func docutils literal"><span class="pre">PyObject_GC_Track()</span></code></a>.  It should not be used for
extension modules.</p>
</dd></dl>

<p>Similarly, the deallocator for the object must conform to a similar pair of
rules:</p>
<ol class="arabic simple">
<li>Before fields which refer to other containers are invalidated,
<a class="reference internal" href="#c.PyObject_GC_UnTrack" title="PyObject_GC_UnTrack"><code class="xref c c-func docutils literal"><span class="pre">PyObject_GC_UnTrack()</span></code></a> must be called.</li>
<li>The object&#8217;s memory must be deallocated using <a class="reference internal" href="#c.PyObject_GC_Del" title="PyObject_GC_Del"><code class="xref c c-func docutils literal"><span class="pre">PyObject_GC_Del()</span></code></a>.</li>
</ol>
<dl class="function">
<dt id="c.PyObject_GC_Del">
void <code class="descname">PyObject_GC_Del</code><span class="sig-paren">(</span>void<em>&nbsp;*op</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyObject_GC_Del" title="Permalink to this definition">¶</a></dt>
<dd><p>Releases memory allocated to an object using <a class="reference internal" href="#c.PyObject_GC_New" title="PyObject_GC_New"><code class="xref c c-func docutils literal"><span class="pre">PyObject_GC_New()</span></code></a> or
<a class="reference internal" href="#c.PyObject_GC_NewVar" title="PyObject_GC_NewVar"><code class="xref c c-func docutils literal"><span class="pre">PyObject_GC_NewVar()</span></code></a>.</p>
</dd></dl>

<dl class="function">
<dt id="c.PyObject_GC_UnTrack">
void <code class="descname">PyObject_GC_UnTrack</code><span class="sig-paren">(</span>void<em>&nbsp;*op</em><span class="sig-paren">)</span><a class="headerlink" href="#c.PyObject_GC_UnTrack" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the object <em>op</em> from the set of container objects tracked by the
collector.  Note that <a class="reference internal" href="#c.PyObject_GC_Track" title="PyObject_GC_Track"><code class="xref c c-func docutils literal"><span class="pre">PyObject_GC_Track()</span></code></a> can be called again on
this object to add it back to the set of tracked objects.  The deallocator
(<a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_dealloc" title="PyTypeObject.tp_dealloc"><code class="xref c c-member docutils literal"><span class="pre">tp_dealloc</span></code></a> handler) should call this for the object before any of
the fields used by the <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code class="xref c c-member docutils literal"><span class="pre">tp_traverse</span></code></a> handler become invalid.</p>
</dd></dl>

<dl class="function">
<dt id="c._PyObject_GC_UNTRACK">
void <code class="descname">_PyObject_GC_UNTRACK</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em>&nbsp;*op</em><span class="sig-paren">)</span><a class="headerlink" href="#c._PyObject_GC_UNTRACK" title="Permalink to this definition">¶</a></dt>
<dd><p>A macro version of <a class="reference internal" href="#c.PyObject_GC_UnTrack" title="PyObject_GC_UnTrack"><code class="xref c c-func docutils literal"><span class="pre">PyObject_GC_UnTrack()</span></code></a>.  It should not be used for
extension modules.</p>
</dd></dl>

<p>The <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code class="xref c c-member docutils literal"><span class="pre">tp_traverse</span></code></a> handler accepts a function parameter of this type:</p>
<dl class="type">
<dt id="c.visitproc">
int <code class="descname">(*visitproc)</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em>&nbsp;*object</em>, void<em>&nbsp;*arg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.visitproc" title="Permalink to this definition">¶</a></dt>
<dd><p>Type of the visitor function passed to the <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code class="xref c c-member docutils literal"><span class="pre">tp_traverse</span></code></a> handler.
The function should be called with an object to traverse as <em>object</em> and
the third parameter to the <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code class="xref c c-member docutils literal"><span class="pre">tp_traverse</span></code></a> handler as <em>arg</em>.  The
Python core uses several visitor functions to implement cyclic garbage
detection; it&#8217;s not expected that users will need to write their own
visitor functions.</p>
</dd></dl>

<p>The <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code class="xref c c-member docutils literal"><span class="pre">tp_traverse</span></code></a> handler must have the following type:</p>
<dl class="type">
<dt id="c.traverseproc">
int <code class="descname">(*traverseproc)</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em>&nbsp;*self</em>, <a class="reference internal" href="#c.visitproc" title="visitproc">visitproc</a><em>&nbsp;visit</em>, void<em>&nbsp;*arg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.traverseproc" title="Permalink to this definition">¶</a></dt>
<dd><p>Traversal function for a container object.  Implementations must call the
<em>visit</em> function for each object directly contained by <em>self</em>, with the
parameters to <em>visit</em> being the contained object and the <em>arg</em> value passed
to the handler.  The <em>visit</em> function must not be called with a <em>NULL</em>
object argument.  If <em>visit</em> returns a non-zero value that value should be
returned immediately.</p>
</dd></dl>

<p>To simplify writing <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code class="xref c c-member docutils literal"><span class="pre">tp_traverse</span></code></a> handlers, a <a class="reference internal" href="#c.Py_VISIT" title="Py_VISIT"><code class="xref c c-func docutils literal"><span class="pre">Py_VISIT()</span></code></a> macro is
provided.  In order to use this macro, the <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code class="xref c c-member docutils literal"><span class="pre">tp_traverse</span></code></a> implementation
must name its arguments exactly <em>visit</em> and <em>arg</em>:</p>
<dl class="function">
<dt id="c.Py_VISIT">
void <code class="descname">Py_VISIT</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em>&nbsp;*o</em><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_VISIT" title="Permalink to this definition">¶</a></dt>
<dd><p>If <em>o</em> is not <em>NULL</em>, call the <em>visit</em> callback, with arguments <em>o</em>
and <em>arg</em>.  If <em>visit</em> returns a non-zero value, then return it.
Using this macro, <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_traverse" title="PyTypeObject.tp_traverse"><code class="xref c c-member docutils literal"><span class="pre">tp_traverse</span></code></a> handlers
look like:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">int</span>
<span class="nf">my_traverse</span><span class="p">(</span><span class="n">Noddy</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">visitproc</span> <span class="n">visit</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Py_VISIT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">foo</span><span class="p">);</span>
    <span class="n">Py_VISIT</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">bar</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</dd></dl>

<p>The <a class="reference internal" href="typeobj.html#c.PyTypeObject.tp_clear" title="PyTypeObject.tp_clear"><code class="xref c c-member docutils literal"><span class="pre">tp_clear</span></code></a> handler must be of the <a class="reference internal" href="#c.inquiry" title="inquiry"><code class="xref c c-type docutils literal"><span class="pre">inquiry</span></code></a> type, or <em>NULL</em>
if the object is immutable.</p>
<dl class="type">
<dt id="c.inquiry">
int <code class="descname">(*inquiry)</code><span class="sig-paren">(</span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject">PyObject</a><em>&nbsp;*self</em><span class="sig-paren">)</span><a class="headerlink" href="#c.inquiry" title="Permalink to this definition">¶</a></dt>
<dd><p>Drop references that may have created reference cycles.  Immutable objects
do not have to define this method since they can never directly create
reference cycles.  Note that the object must still be valid after calling
this method (don&#8217;t just call <a class="reference internal" href="refcounting.html#c.Py_DECREF" title="Py_DECREF"><code class="xref c c-func docutils literal"><span class="pre">Py_DECREF()</span></code></a> on a reference).  The
collector will call this method if it detects that this object is involved
in a reference cycle.</p>
</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
    <a id="sidebar-anchor"></a>
    

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/c-api/gcsupport.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
      </ul>
    </div>

    <div class="footer" role="contentinfo">
        &#169; <a href="../copyright.html">Copyright</a> 2016, Trần Viết Sơn.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.4.6.
    </div>
  </body>
</html>